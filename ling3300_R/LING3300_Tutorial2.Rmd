---
title: "LING 3300 - Tutorial 2"
author: "Thomas Kettig"
date: "January 8, 2026"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


### Installing packages
In general, it's useful to know how to install and update packages. Packages are bundles of code that you can import into R. They're sort of like software applications that you install and then open up when needed. They give you way more coding options and power than just using the stuff that R comes pre-loaded with - imagine buying an iPad and then not downloading any new apps to it! That wouldn't be very fun. 

One package we'll be using today is called **tidyverse**. Actually, the tidyverse contains *several* R packages that are incredibly useful for data analysis and visualization. These packages include ggplot2, dplyr, tidyr, readr, and some others. The tidyverse is also a philosophy for maintaining datasets and general data and code hygiene. While we may not have enough time to go over this in detail, we will implicitly be adhering to several (but possibly not all) of these principles throughout the module. The principles are definitely worth reading about, so Google "tidyverse" if you're interested in knowing more.

If you're connected to the internet, you can install/update a package with the following code:

```{r eval = FALSE}
install.packages("tidyverse")
```

You're not done yet! You now "own" the package but you still need to pull the package "off the shelf" to use the code. You can import the package with either the library() or require() functions -- they're basically the same thing. Yes, you do have to write this line of code everytime you restart R and want to access the code again! That means that most of your scripts will begin with two bits of code: reading in the data you want to work with and reading in the packages you need.

```{r eval = T}
library(tidyverse)
# or
require(tidyverse)
```

Alternatively, you can click the "Packages" tab in the lower righthand corner, and check the box for the packages you want to use.

Don't worry if some warnings come up when you load in packages. They just contain information like the version of R that they were built in. You usually won't have to worry about this.


## Data visualization in R with ggplot2

One of the main (best) packages for **data visualization in R** is the [ggplot2](https://ggplot2.tidyverse.org/).  package. This package is also part of the tidyverse suite of packages, and is commonly referred to as "ggplot". If you have installed tidyverse and loaded it in using the library() or require() functions, then ggplot2 will automatically be loaded too. You can read more about the background to ggplot2 [here](https://qz.com/1007328/all-hail-ggplot2-the-code-powering-all-those-excellent-charts-is-10-years-old/). 

ggplot code is fairly templatic, and works by creating "layers" to a plot. You will always need the following three components in your ggplot code:

+ the ggplot() function that tells R you want to create a graph with some data frame
+ the geom_X() function where X refers to the specific type of plot you want to make (histogram, scatterplot, etc.). We'll go over some possible geom_X functions below
+ an aesthetics mapping aes() that tells R how to arrange the variables on the plot

### Some examples of the ggplot() structure:
```{r eval = T}
ggplot(mydata) + 
  geom_histogram(aes(x = var1))

ggplot(mydata) + 
  geom_boxplot(aes(x = var1, y = var2))

ggplot(mydata) + 
  geom_point(aes(x = var1, y = var2))

ggplot(mydata) + 
  geom_bar(aes(x = var1, y = the_count))
```

You can put the aesthetics mapping in either the geom_X() function or the ggplot() function. Sometimes it makes a difference; sometimes not: if you find yourself running into an issue, I would recommend putting the aes() mapping in the main ggplot() function.

```{r eval = T}
ggplot(mydata, aes(x = var1, y = var2)) + 
  geom_point() 
```

### Load in the dataset
```{r eval = T}
jury <- read.csv("/Users/Thomas/Documents/York (Canada)/LING 3300/Datasets/Jury/jury_data_basic.csv", header = TRUE)
View(jury)
```

Remember - here you should change the path that's between the " " so that it points to where on YOUR computer the .csv is. If you don't know how to do this easily, Google "how to find the path name of a file" + your operating system (Mac, Windows 10, etc.). This will be a very valuable skill going forward, so master it now!

Also remember that the reason we put header = TRUE is so that R knows that the first line of our csv is the names of our columns, not data itself.


### Histograms

When you want to plot the distribution of **one continuous variable**, use a histogram:
```{r eval = T}
ggplot(mcm) + 
  geom_histogram(aes(x = dur_f))
```

The binwidth warning simply tells you that it's using a default binwidth for grouping the counts together.
The other warning indicating it removed rows refers to the fact that 7 of the values in the dur_f column are actually "NA" values, so can't be represented in the histogram. You'll frequently see this warning below; it's usually safe to ignore unless you know that none of the values are missing. 

### Boxplots
When you want to plot the distribution of one continuous variable, but for separate categories, you can use a boxplot.

```{r eval = T}
ggplot(mcm) + 
  geom_boxplot(aes(x = Fricative, y = dur_f))
```

### Scatterplots
When you have **two continuous variables** and you want to show the relationship between them, you'll want a scatterplot. Think carefully about which variable you'll want on the x-axis, and which one on the y-axis:

```{r eval = T}
ggplot(mcm) + 
  geom_point(aes(x = dur_f, y = F0))
```

### Bar graphs
When you want to display the **count or proportion** of different levels of a categorical variable, you'll want a bar graph:

```{r eval = T}
ggplot(mcm) + 
  geom_bar(aes(x = Fricative))
```

That bar graph is a little boring and uninformative, though, as we have an equal number of occurrences for each fricative! Let's make a new categorical variable in our dataset that simply categorizes someone's F0 into a "high F0" category and a "low F0" category. If the F0 is greater than 200, let's call it "high", otherwise it's low. Note the use of the ifelse() function in this case:

```{r eval = T}
mcm$highf0 <- ifelse(mcm$F0 > 200, "high", "low")
xtabs(~highf0, mcm)
```

Now let's create a bar graph that shows us the number of tokens in each F0 bin. We'll use x = highf0 which will list each level of the highf0 column ("high", "low") along the x-axis.

```{r eval = T}
ggplot(mcm) + geom_bar(aes(x = highf0))
```

Some of the f0 values are "NA", which is now showing up in our plot. To drop these values, we need to take a *subset* of the dataset which drops the NA values. Remember that the exclamation point ! means "not" 

```{r eval = T}
mcm_subset <- subset(mcm, !is.na(highf0))
ggplot(mcm_subset) + 
  geom_bar(aes(x = highf0))
```

### Layering

#### Facetting

Let's say we want a separate scatterplot looking at the relationship between the duration of the fricative (dur_f) and the duration of the vowel (dur_v) for each fricative **separately**. We can use facet_wrap(~Fricative) to split this up:

```{r eval = T}
ggplot(mcm) + 
  geom_point(aes(x = dur_f, y = dur_v)) + 
  facet_wrap(~Fricative)
```

You can combine facet_wrap() with any plot. Here's an example with a histogram:

```{r eval = T}
ggplot(mcm) + 
  geom_histogram(aes(x = dur_f)) + 
  facet_wrap(~Fricative)
```

#### Axis labels
It's important to put informative labels on your x- and y-axes, and your column names might not provide that. You can use the xlab() and ylab() functions to add an axis label. 

For example:

```{r eval = T}
ggplot(mcm) + 
  geom_boxplot(aes(x = Fricative, y = dur_f)) +
  xlab("fricative") + 
  ylab("fricative duration (ms)") 
```

#### Axis limits
Sometimes you want to truncate the displayed data on the axes, or make sure it's very consistent. You can specify an exact range by using the functions xlim(number1, number2) and ylim(number1, number2). Example below:

```{r eval = T}
ggplot(mcm) + 
  geom_point(aes(x = F0, y = F1)) +
  xlim(50, 400) +
  ylim(100, 1000)
```

#### Colors
There are [so many colors in R!](http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf)

There are confusingly two ggplot arguments that will make use of color:

+ the **color** argument
+ the **fill** argument

The color argument actually just changes the outline color. The fill argument will refer to the color of a column in e.g., a bar graph or histogram. 

We'll first start with an example where we keep the outline color **constant** across every variable in the figure. When you want everything to be the same color, you put the color variable **outside** of the aes() function, but within the geom_X() function:

```{r eval = T}
ggplot(mcm) + 
  geom_histogram(aes(x = dur_f), color = "rosybrown2")
```

So you can see how the color doesn't change, let's add the facet_wrap() argument:
```{r eval = T}
ggplot(mcm) + 
  geom_histogram(aes(x = dur_f), color = "rosybrown2") +
  facet_wrap(~Fricative)
```

We can do the exact same thing with **fill**. Note the difference:
```{r eval = T}
ggplot(mcm) + 
  geom_histogram(aes(x = dur_f), fill = "rosybrown2")
```

You can also combine the two; order doesn't matter:
```{r eval = T}
ggplot(mcm) + 
  geom_histogram(aes(x = dur_f), color = "black", fill = "rosybrown2")
```

The second set of examples will be where the color **changes** with the level of a categorical variable. This can be a pretty powerful mapping in your figures. For example, we can have boxplots of the fricative duration for each fricative, that's plotted on the x-axis, and use color to split the boxplots by gender (another categorical variable). To do this, we put **color** or **fill** **inside the aes() mapping.** When we do this, the color or fill is **mapped** to some variable. Note that we then lose the immediate ability to specify the color that R uses, but we'll return to that in a moment. Also important to note is that there are several options that can go inside the aes() mapping besides **color** or **fill** including the size of a point, the shape of a point, the line type (dashed or solid), etc. I recommend looking this up online if it interests you. 

First we also need to create the gender column -- just go with me on this code:

```{r eval = T}
mcm$gender <- substr(mcm$Talker, 1, 1)
ggplot(mcm) + 
  geom_boxplot(aes(x = Fricative, y = dur_f, fill = gender))
```

Further examples:
```{r eval = T}
ggplot(mcm) + 
  geom_boxplot(aes(x = Fricative, y = dur_f, color = Fricative))
ggplot(mcm) + 
  geom_boxplot(aes(x = Fricative, y = dur_f, color = Vowel))
```


#### Change the color of the mapping
You can see how R used some default colors to map gender to the boxplot. You can also overwrite this using the scale_fill_manual() function. Let's take look at how this works:

```{r eval = T}
ggplot(mcm) + 
  geom_boxplot(aes(x = Fricative, y = dur_f, fill = gender)) + 
  scale_fill_manual(values = c("rosybrown2", "lightblue"))
```

There are also some automatic color scales in R, and ones that work for colorblindness, etc. Some more info can be found by googling "color palettes" in R, and some good examples are on [this page](https://www.datanovia.com/en/blog/top-r-color-palettes-to-know-for-great-data-visualization/). 

#### Background theme
You can change the "theme" of the R plot, which generally includes the background color, the presence of grid lines, the font size, and a few other things using some theme_X() functions. The default theme with the gray background is theme_gray(); many people like the theme_bw() background which uses a white background. There are several more theme_X() options in the ggthemes package.

Let's first take a look at the theme_bw() function. You can put the font size in the parentheses *if you want*. (Note also the specification of the binwidth in this histogram):

```{r eval = T}
ggplot(mcm) + 
  geom_histogram(aes(x = dur_f), fill = "rosybrown2", color = "black", binwidth = 10) + 
  xlab("fricative duration (ms)") + 
  theme_bw(20)
```

We can also install the [ggthemes](https://yutannihilation.github.io/allYourFigureAreBelongToUs/ggthemes/) package to gain access to a few more themes:
```{r eval = F}
install.packages("ggthemes")
```
```{r eval = T}
library(ggthemes)
```

Let's use The Economist theme on a scatterplot of the vowel F1 and F2 just for fun...
```{r eval = T}
ggplot(mcm) + 
  geom_point(aes(x = F2, y = F1, color = Vowel)) + 
  theme_economist(18) + 
  xlab("F2 (Hz)") +
  ylab("F1 (Hz)") 
```

#### Reversing continuous axes
You can also reverse an axis, which can be very useful for creating things like vowel plots! Let's take the example above of the F1 x F2 space for vowels, and make it look like a standard vowel plot by reversing the direction of the two axes. You can do this with the functions scale_x_reverse() and scale_y_reverse(). Let's use a different theme from the ggthemes package too -- one of my favorites is theme_few():

```{r eval = T}
ggplot(mcm) + 
  geom_point(aes(x = F2, y = F1, color = Vowel)) + 
  theme_few(18) + 
  xlab("F2 (Hz)") +
  ylab("F1 (Hz)") +
  scale_x_reverse() + 
  scale_y_reverse()
```

#### Reordering levels of a variable
By default, R orders the levels of a categorical variable **alphabetically**. In the above example with Vowel, you can see that it first listed "a", then "eh", then "ei", then "i", then "o", then "u". Sometimes this is fine, but sometimes you want to change the order that's presented. For example, you might want the order of the Vowels to be a little more phonetically ordered, so something like

+ i
+ ei
+ eh
+ a
+ o 
+ u

which creates somewhat of a circle around the F1xF2 vowel space (or articulatory goes from high front, down the front vowels, and up the back vowels). To do this, you have to use the factor() function on the column you want to reorder.

```{r eval = T}
mcm$Vowel <- factor(mcm$Vowel, levels = c("i", "ei", "eh", "a", "o", "u"))
```

Now try replotting:
```{r eval = T}
ggplot(mcm) + 
  geom_point(aes(x = F2, y = F1, color = Vowel)) + 
  theme_few(18) + 
  xlab("F2 (Hz)") +
  ylab("F1 (Hz)") +
  scale_x_reverse() + 
  scale_y_reverse()
```

### Saving images
You can save an image using various file formats. The simplest way to save an image is to click on the Export... button in the Plots panel. You should have the option save either as a PNG or as a PDF file there. One tip: increase the dimensions by a lot, otherwise the resolution will be crap. PNG is actually pretty hard to work with in my opinion. You'll need to bump the numbers up to around 1000-2000 pixels, and then play around with the font size. 

The Export option for Save as PDF is a little easier to work with, but note that PDF images **do not** transfer well between Mac and Windows computers. It's usually the case that PDF images created on Macs do not work well on Windows, but it could also be vice versa... In any case, a PDF image should probably be around 7 to 12 inches. (This one only works in inches.) 

The alternative option is to wrap the figure you want to save with the pdf() - dev.off() sequence, or alternatively a png() - dev.off() sequence. I'll show the pdf() example first, but because PDFs do not transfer well from Macs to Windows, the best option might be the last one presented here (the png() - dev.off() sequence). In any case, the first argument in the pdf() function is the name and location of the file you want to create, and then the height and width in inches. For PDF, you can only specify the dimensions in inches. 
```{r eval = F}
pdf("C:/Users/ep1290/OneDrive - University of York/Desktop/QM/vowelplot.pdf", height = 7, width = 10)
ggplot(mcm) + 
  geom_point(aes(x = F2, y = F1, color = Vowel)) + 
  theme_few(18) + 
  xlab("F2 (Hz)") +
  ylab("F1 (Hz)") +
  scale_x_reverse() + 
  scale_y_reverse()
dev.off()
```

Alternatively, you can do png()-dev.off() or jpeg()-dev.off or tiff()-dev.off(). You can and should specify the units and resolution with these. Example units include pixels, inches, centimeters, or millimeters. If you use a unit besides pixels, you need to specify the resolution in pixels per inch (or per cm, etc.). A basic resolution is 72ppi, but I would recommend using resolutions between 200 and 300ppi.  The file just takes up more space on your computer. (300ppi is commonly recommended for print in books and journals.) To see more about your options, check the help page:
```{r eval = F}
?png

png("C:/Users/ep1290/OneDrive - University of York/Desktop/QM/vowelplot.png", units = "in", height = 7, width = 10, res = 300)
ggplot(mcm) + 
  geom_point(aes(x = F2, y = F1, color = Vowel)) + 
  theme_few(18) + 
  xlab("F2 (Hz)") +
  ylab("F1 (Hz)") +
  scale_x_reverse() + 
  scale_y_reverse()
dev.off()

ggsave("myplot.jpeg", width = 7, height = 10, dpi = 300)
```

### Practice
Create an R script to save the answers to these questions.

1. Import 'L2_English_Lexical_Decision_Data.csv' into R and call it 'lex'. This data set contains reaction times (RT) in milliseconds to words and nonwords of English from L2 English speaking participants. More info about the data and project [here](https://osf.io/msnpr/).

2. Create a histogram of the reaction times (RT column). It will probably look weird because of the extreme range of RTs.
3. Get a summary of the RT values, and take a look at the maximum value. Something can't be right there.
4. Create another histogram of the reaction times where the x-axis only includes values from 0 to 5000 ms.
5. Based on the histogram, it looks like values above 2500 seem pretty improbable. Create a subset of lex which only retains reaction times below 2500 ms. Call this lex again.
6. Create another histogram of reaction times using the new dataset and change the background theme, along with the outline color and fill of the bars. 

7. Let's say we're interested in comparing reaction times of L1 English speakers against L2 English speakers. Create a new column called 'L2' that indicates whether a speaker's dominant language is English or not English. Specifically, if the domLang column is equal to English, the value in the L2 column should be "L1 English", otherwise the value in the L2 column should be "L2 English".
8. Let's also say we might want to look at any potential effects of gender. Create another column in lex called 'gender'. If the sex of the participant is equal to 1, then the new value in the 'gender' column should be "m" for male, otherwise the new value should be "f".
9. Create a boxplot with the L2 status on the x-axis and the reaction time on the y-axis.
10. Recreate the same boxplot in 8, but use the aesthetic mapping to map color to the gender column. 
11. Recreate the same boxplot in 9, but also change the background theme and provide more descriptive labels. 


12. Create a new column called 'accuracy'. If the column 'acc' is equal to 1, then the value in 'accuracy' should be equal to "right", otherwise the value should be equal to "wrong".
13. Create a bar graph with accuracy on the x-axis and the fill of the bar mapped to the L2 status. This should create what's called a "stacked" bar graph, where the number of "right" answers for L1 English speakers is stacked on top of the number of "right" answers for L2 English speakers.
14. To create a "dodged" bar graph where the bars are **next to each other**, you'll need to use the following argument:

```{r eval = F}
geom_bar(aes(x = accuracy, fill = L2), position = "dodge")
```

Give that a try. 

15. Now take the same graph from 14 and change the background theme and colors.

16. Now we need to practice creating a scatterplot, but sadly there aren't two **good** continuous variables in the lex dataset. We'll instead use the **mcm** dataset. If you don't have that loaded in to your R workspace, load that in now. 
17. Make sure you have the column for 'gender'. If you don't have this column, you can recreate it using the following line of code:

```{r eval = F}
mcm$gender <- substr(mcm$Talker, 1, 1)
```

18. Create a scatterplot that allows us to visualize the relationship between F1 and F0. Put F1 on the x-axis and F0 on the y-axis.
19. You might have noticed that F0 looks a little bimodal. This is likely due to gender differences. Create the same scatterplot in 18 but map color to gender.
20. Now take the same scatterplot from 18 and facet by vowel category (Vowel). 
21. Reorder the vowel category so it shows up as: "i", "ei", "eh", "a", "o", "u". 
22. Now recreate the scatterplot from 20 and also change the background theme and add a little more detail to the axis labels (i.e., that these measures are in Hz).

